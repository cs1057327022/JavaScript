# 正则
正则使用工具:  http://regexper.com 
正则入门：https://www.jb51.net/tools/zhengze.html

### 修饰符
g: 全局匹配  
   可以匹配到 0-多个结果
i: 匹配大小写 
m 多行匹配

### 元字符
正则表达式有两种基本字符 元字符 原义文本字符
原义概念：表示代表本来文本的字符；
元字符：再正则表达式中有特殊意义的字符
.* + ? $ ^ | \ () {} [] \n \d \w \r\ Q \f \b \cX......

[]  或  字符类；将一堆字符放在一个字符类中，匹配结果为一个字符。字符长度有【量词】决定
{}  量词  作用；决定匹配字符的长度。每个正则字符值匹配一个字符；量词决定结果字符长度0-n.
() 

.
+
*
?
^
$
\b
\d
\w
\n
\r
\f

### 字符类[]
一般情况下，一个字符对应一个字符串

特殊：需要配【某类】字符
1：使用[]来构建简单的类
2： 所谓的类是指符合某些特性的对象；一个泛指；而不是特定某个字符
例如[abc] 匹配  a或 b 或 c 中其中一类就可以

### 字符类取反 [^]
1：使用 ^ 创建反向类  必须在[^] 内
2：不属于某类

~~~
[^abc] 除了a b c 凄然字符都匹配
~~~



### 范围类
1:[a-z] 匹配 a-z 任意字符 
  闭意区间表示包含a z 本身
2:在 [] 主城的类可以连写 [a-zA-Z]


### 预定义类
作用：匹配常见的字符
。  [^\r\n] 任意字符 除了回车和换行的
\d  [0-9]
\s  [' ']
\S  [^' ']
\w  [a-zA-Z0-9_]
#### 边界匹配的字符
^  开头  ^[123]{4}
$  结尾     
\b 单词边界
\B 非单词边界                                      

###  量词
量词：是匹配一个字符的长度多少？
匹配一个连续出现20次的字符；字符长度为20 
? 出现0次或者1次  /\d{0,1}/  /\d?/
+ 一次或者多次  {1,}
* 出现0次或者多次  {0,}
{n} 一个正则字符出现n次  
{n,m} 出现n到m 次
{n,} 至少出现n 次


### 贪婪模式 非贪婪模式
\d{3，6} 贪婪模式 尽可能多的匹配

\d{3,6}? 非贪婪模式；尽可能少的匹配

常见的贪婪模式

~~~
{3，6}
{1，}
~~~



### 分组：
需求：撇需yyc 连续3次出现次数
yyc{3}  c3次
(yyc){3}

1：小写英文字母数字练习出现3次、

### 或
多个分支走任意一个分支都可以
| 或
(yyc|wjr) yyc或者wjr

### 反项引用
$1$2$3 捕获分组中的内容
### 忽略分组

不想捕获某个分组时候，在分前后面加上?:就可以了 
例如：
(?:yyc) 不会捕获到yyc

### 前zan瞻
正则表达式从头到尾的解析 文本尾部叫做【前】 文本头部叫做后
1：前瞻就是正则表达式匹配到规则时候；向前价查是否符合【断言】，后顾/后瞻方向相反
2：js不支持后顾
3：符合和不符合特定断言叫做肯定/正向匹配；和否定/负向匹配
正向匹配： 既要符合正则也要符合断言 exp(?=assert); exp规则部分（?=assert）断言部分.
  - 例如 \w(?=\d) 匹配到\w 后 还要往后看看 是不是数字

负向匹配   exp(?!assert)

正向前瞻往后看断言，负向前瞻 往前看断言
#### 断言
(?=pattern) 正向先行断言
代表字符串中的一个位置，紧接该位置之后的字符序列能够匹配pattern。
例如对”a regular expression”这个字符串，要想匹配regular中的re，但不能匹配expression中的re，可以用”re(?=gular)”，该表达式限定了re右边的位置，这个位置之后是gular，但并不消耗gular这些字符，将表达式改为”re(?=gular).”，将会匹配reg，元字符.匹配了g，括号这一砣匹配了e和g之间的位置。

(?!pattern) 负向先行断言
代表字符串中的一个位置，紧接该位置之后的字符序列不能匹配pattern。
例如对”regex represents regular expression”这个字符串，要想匹配除regex和regular之外的re，可以用”re(?!g)”，该表达式限定了re右边的位置，这个位置后面不是字符g。负向和正向的区别，就在于该位置之后的字符能否匹配括号中的表达式。

(?<=pattern) 正向后行断言
代表字符串中的一个位置，紧接该位置之前的字符序列能够匹配pattern。
例如对”regex represents regular expression”这个字符串，有4个单词，要想匹配单词内部的re，但不匹配单词开头的re，可以用”(?<=\w)re”，单词内部的re，在re前面应该是一个单词字符。之所以叫后行断言，是因为正则表达式引擎在匹配字符串和表达式时，是从前向后逐个扫描字符串中的字符，并判断是否与表达式符合，当在表达式中遇到该断言时，正则表达式引擎需要往字符串前端检测已扫描过的字符，相对于扫描方向是向后的。

(?<!pattern)       
代表字符串中的一个位置，紧接该位置之前的字符序列不能匹配pattern。
例如对”regex represents regular expression”这个字符串，要想匹配单词开头的re，可以用”(?<!\w)re”。单词开头的re，在本例中，也就是指不在单词内部的re，即re前面不是单词字符。当然也可以用”\bre”来匹配。

### 正则属性
1: global 是否是全局搜索；默认false
2：ignore case: 是否对忽略大小写  默认false 
3：multiline 多行搜索  默认false 
4: lastIndex 当前表达式匹配内容的最后一个字符的下一个字符
5：source 正则表达式文本字符

### 正则方法
reg.test(str)
    作用检测是否有匹配到的结果
reg.exec(str)
exec() 方法检索字符串中的指定值。如果没有发现匹配，
   则返回 null。返回值是被找到的值 结果为数组。
    - index 声明匹配文本第一个字符的位置
    - input 存放被检索的字符串
#### 非全局调用
- 调用非全局的RegExp 对象中exce 返回一个数组
-  第一个元素式正则表达式匹配的文本
- 第二个元素式与 RegExpObject 的第一个字表达式（第一个分组） 匹配的文本
- 第三个元素式与RegExp 对象的第二个子表达式相匹配的文本（第二个分组）
~~~js
var reg = /\d(\w)\d/
var reg1  = /\d(\w)\d/g;
var str = '1a2b3c3d5e';
var res = reg.exec(str)

console.log(reg.lastIndex+'\t'+res.index+res.toString());
console.log(reg1.lastIndex+'\t'+res.index+res.toString());
console.log(reg1.lastIndex+'\t'+res.index+res.toString());

~~~
