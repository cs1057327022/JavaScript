<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 引用
        // 分类：显示引用和隐式引用

        // 显示引用:一个对象访问另一个对象下属性
        // --->一个对象引用另一个对象
        // 隐式引用:一个对象,通过原型地域性访问的属性

        // 对象指的是:GO AO 函数对象 普通对象

        // 引用计数垃圾手机
        // --->关键看,一个对象是否被其他对象所引用(使用)
        // 零引用的对象:被垃圾回收机制所回收

            var o = {
                a: {
                    b: 2
                }
            }; 
        // 两个对象,一个key为a 一个key为b
        // 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o
        // 很显然，没有一个可以被垃圾收集
        var o2 = o//o2 引用key 为a的对象
        o=1 //o //这个时候只有o2引用 key为a的对象 o不在引用了
        var oa = o2.a //key为b的对象 被oa变量 和 a属性引用
        o2 = 'yo' // 虽然最初的对象现在已经是零引用了，可以被垃圾回收了
                  // 但是它的属性a的对象还在被oa引用，所以还不能回收
        oa = null // a属性的那个对象现在也是零引用了 它可以被垃圾回收了


        // 总结：代码从头指向到位 如果说这个对象，以及对象中属性，没有被任何全局变量所引用(直接，间接) 那么这个对象就会被回收

        // 循环引用：(学术观点不同)，浏览器底层处理的方式不同 IE 6,7 内存泄漏(符合引用计算垃圾算法) 其他浏览器：可能用的是 循环引用算法 和 引用计算垃圾算法
    </script>
</body>
</html>